## 어플리케이션 설계

### 소프트웨어 아키텍처

1. 소프트웨어 아키텍처의 설계
   - 소프트웨어 아키텍처는 소프트웨어의 골격이 되는 기본 구조이다, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.
   - 소프트웨어 개발 시 적용되는 원칙과 지침이며, 이해 관계자들이 의사소통 도구로 활용된다.
   - 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정이다.
   - 어플리케이션의 분할 방법과 분할된 모듈에 할당된 기능, 모듈 간의 인터페이스를 결정한다.
   - 소프트웨어 아키텍처 설계의 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보은닉 등이 있다.
2. 모듈화 (Modularity)
   - 모듈화란 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.
   - 자주 사용되는 계산식이나, 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상시킬 수 있다.
   - 모듈의 크기를 너무 작게 나누면 갯수가 많아져 모듈 간의 통합 비용이 너무 많이 들고, 너무 크게 나누면 갯수가 적어 통합 비용은 적게들지만 모듈하나의 개발 비용이 많이 든다.
3. 추상화 (Abstraction)
   - 추상화는 문제의 전체적이고 포관적인 개념을 설계한 후 차례로 세분화 하여 구체화시켜 나가는 것이다.
   - 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법으로, 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다.
   - 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다.
   - 과정, 데이터, 제어 등을 추상화 할 수 있다.
4. 단계적 분해 (Strpwise Refinement)
   - 단계적 분해는 하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.
   - 추상화의 반복에 의해 세분화 된다. 자바의 경우 abstract를 통해서 사용가능한 기능을 정의하고 관계를 가지는 아래로 계속해서 내려가면서 그 기능을 구체화 한다.
   - 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 뒤로 미루어 진행한다.
5. 정보 은닉 (Information Hiding)
   - 정보 은닉은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.
   - 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은식된 모듈과 커뮤니케이션할 필요가 있을 때는 필요한 정보만 인터페이스를 통해 주고 받는다.
   - 정보 은닉을 통해 모듈을 독집적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.
6. 소프트웨어 아키텍쳐의 품질 속성
   - 소프트웨어 아키텍쳐의 품질 속성은 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 시스템측면, 아키텍처 측면으로 구분하여 구체화시켜 놓은 것이다.
7. 소프트웨어 아키텍처의 설계 과정
   - 아키텍처의 설계 과정은 설계 목표 설정, 시스템 타입 결정, 아키텍쳐 패턴 적용, 서브시스템 구체화, 검토 순으로 진행한다.

### 아키텍처 패턴

1. 아키텍처 패턴의 개요
   - 아키텍처 패턴은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
   - 아키텍처 패턴에는 서브시스템들과 그 역활이 정의되어 있으며, 서브 시스템 사이의 관계와 여러 규칙, 지침등이 포함되어 있다.
   - 아키턱처 패턴을 아키텍처 스타일 또는 표준 아키텍처라고 한다.
   - 아키텍처 패턴의 장점
     - 시행착오를 줄여 개발 시간을 단축시키고, 고품질의 소프트웨어를 생산할 수 있다.
     - 검증된 구조로 개발하기 때문에 안정적인 개발이 가능하다.
     - 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해 진다.
     - 시스템의 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지보수를 진행 할 수 있다.
     - 시스템의 특성을 개발 전에 예측하는 것이 가능해진다.
2. 레이어 패턴 (Layers Pattern)
   - 레이어 패턴은 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나다.
   - 레이어 패턴은 각각의 서브시스템들이 계층구조를 이루며, 상위 계층은 하위 계츨에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다.
   - 레이어 패턴은 서로 마주보는 두개의 계층 사이에서만 상호작용이 이루어지며, 변경 사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이하다.
   - 레이어 패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다.
   - 대표적으로 OSI 7 계층이 있다.
3. 클라이언트-서버 패턴 (Client-Serve Pattern)
   - 클라이언트-서버 패턴은 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다.
   - 클라이언트-서버 패턴에서 사용자는 클라이언트와만 의사소통을 한다. 즉 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다.
   - 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다.
   - 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다.
4. 파이프-필터 패턴(Pipe-Filter Pattern)
   - 파이프-필터 패턴은 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다.
   - 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장에 용이하다.
   - 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 사용된다.
   - 대표적으로 UNIX의 Shell이 있다.
5. 모델-뷰-컨트롤러 패턴 (Model - View - Controller Pattern)
   - 모델 뷰 컨트롤러 패턴은 서브시스템을 3개의 부분으로 구조화하는 패턴이며, 각 부분의 역활은 다음과 같다.
   - 모델 (Model) : 서브시스템의 핵심 기능과 데이터를 보관한다.
   - 뷰 (View) : 사용자에게 정보를 표시한다.
   - 컨트롤러 (Controller) : 사용자로부터 받은 입력을 처리한다.
   - 모델 뷰 컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업릉 수행할 수 있다.
   - 모델 뷰 컨트롤러 패턴에서는 여러 개의 뷰를 만들 수 있으므로 한개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 허플리케이션에 적합하다.
6. 기타 패턴
   - 마스터-슬레이브 패턴 : 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴이다.
   - 브로커 패턴 : 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해 준다.
   - 피어 투 피어 패턴 : 피어를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호풀하는 클라이언트가 될 수도 , 서비스를 제공하는 서버가 될 수도 있는 패턴이다.
   - 이벤트 버스 패턴 : 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 패널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식이다.
   - 블랙보드 패턴 : 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다.
   - 인터프리터 패턴 : 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된다.

### 객체지향(Object-Oriented)

1. 객체지향의 개요
   - 객체지향은 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법을 말한다.
   - 객체지향 기법은 구조적 기법의 문제점으로 인한 소프트웨어 위기를 해결책으로 채택되어 사용되고 있다.
   - 갹채지향은 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.
   - 객체지향은 복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬처리를 지원한다.
   - 객체지향은 현실 세계를 모형화하므로 사용자와 개발자가 쉽게 이해할 수 있다.
   - 객체지향의 주요 구성 요소와 개념에는 객체(Object), 클래스(Class), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있다.
2. 객체 (Object)
   - 객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈이다.
   - 데이터 : 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다.
   - 함수 : 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘이다.
   - 객체의 특징 : 객체는 독립적으로 식별 가능한 이름을 가지고 있다, 객체가 가질 수 있는 조건을 상태라고 하는데 일반적으로 상태는 시간에 따라 변한다, 객체와 객체는 상호 연관성에 의한 관계가 형성된다, 객체가 반응 할 수 있는 메시지의 집합을 행위라고 하며, 객체는 행위의 특징을 나타낼 수 있다, 객체는 일정한 기억장소를 가지고 있다, 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다.
3. 클래스(Class)
   - 클래스는 공통된 속성과 연산을 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미한다.
   - 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
   - 클래스에 속한 각각의 객체를 인스턴스라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 한다.
   - 동일 클래스에 속한 각각의 객체들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타내게 된다.
   - 최상위 클래스는 상위 클래스를 가지지 않는 클래스를 말한다.
   - 슈퍼 클래스는 특정 클래스의 상위 클래스이고, 서브 클래스는 특정 클래스의 하위 클래스이다.
4. 캡슐화(Encapsulation)
   - 캡슐화는 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.
   - 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐되어 외부의 접근이 제한적이기 떄문에 외부 모듈의 변경으로 인한 파급효과가 적다.
   - 캡슐화된 객체들은 재사용이 용이하다.
   - 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.
5. 상속(Inheritance)
   - 상속은 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.
   - 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스내에서 다시 정의하지 않고서도 즉시 자신의 속성을 사용할 수 있다.
   - 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.
   - 상위 클래스의 속성과 연산을 하위 클래스가 사용할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어의 재사용성을 높이는 중요한 개념이다.
6. 다형성(Polymorphism)
   - 다형성은 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미한다.
   - 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
   - 응용 프로그램 상에서 하나의 함수나 연산가자 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것이다.

### 모듈 (Module)

1. 모듈의 개요
   - 모듈은 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위등과 같은 의미로 사용된다.
   - 모듈은 단독으로 컴파일이 가능하며, 재상용 할 수 있다.
   - 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과동한 상호작용을 배제함으로써 이루어진다.
   - 독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있다.
   - 모듈의 독립성은 결합도, 응집도에 의해 측정되며 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다.
2. 결합도
   - 결합도는 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다.
   - 다양한 결합으로 모듈을 구성할 수 있으나, 결합도가 약할수록 품질이 높고, 강할 수록 품질이 낮다.
3. 응집도
   - 응집도는 정보은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미한다.
   - 다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다.
4. 팬인, 팬아웃 (Fan-In, Fan-Out)
   - 팬인은 어떤 모듈을 제어하는 모듈의 수를 나타낸다.
   - 팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수를 나타낸다.
   - 이를 분석해서 시스템의 복잡도를 분석할 수 있다.

### 코드

1. 코드의 개요
   - 코드는 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호이다.
   - 코드는 정보를 신속, 정확, 명료하게 전달할 수 있게 한다.
2. 코드의 종류
   - 순차 코드
   - 블록 코드
   - 10진 코드
   - 그룹 분류 코드
   - 연상 코드
   - 표의 숫자 코드
   - 합성 코드
3. 코드 부여 체계
   - 코드 부여 체계는 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식을 말한다. -> 교유한 약속을 통해서 이러한 규칙을 정하기도 한다.

### 디자인 패턴

1. 디자인 패턴(Design Pattern)의 개요
   - 디자인 패턴은 각 모듈의 세분화된 역활이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해경 방식 또는 예제를 의미한다.
   - 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개로 구성되어 진다.
2. 생성 패턴
   - Abstract Factory
   - Builder
   - Factory Method
   - Prototype
   - Singleton
3. 구조 패턴
   - Adapter
   - Bridge
   - Composite
   - Decorator
   - Facade
   - Flyweight
   - Proxy
4. 행위 패턴
   - Chain of Responsibility
   - Command
   - Interpreter
   - Iterator
   - Mediator
   - Memonto
   - Observer
   - State
   - Strategy
   - Template Method
   - Visitor
